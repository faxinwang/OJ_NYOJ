/*
n==1 或者 n==2，所有人直接过河即可；
如果n==3，用时最短的和用时最长的一起过去，然后用时最短的回来，再和剩下的一个人过去 ；
如果n>=4，设a[0]表示用时最短的人所用的时间，a[1]为用时第二短的人所用的时间，a[n-1]表示用时
最长的人所用的时间，a[n-2]表示用时第二长的人所用的时间。那么：
当2a[1] + a[0] + a[n-1] > 2a[0] + a[n-1] + a[n-2]时，就先让用时最短的人和用时最长的人一起过去，
然后用时最短的回来，接着让用时最短的和用时第二长的一起过去，再让用时最短的回来。
否则，就先让用时最短的和用时第二短的一起过去，然后用时最短的回来，接着让用时最长和用时第二长的
一起过去，再让用时第二短的回来。这样就相当于剩下了n-2个人。对这n-2个人执行相同的操作，直到剩下
不足4个人即可直接结算所需的时间.
参考: http://blog.csdn.net/lyhvoyage/article/details/23196933

可以看出, 整个过程中一直都是最快和第二快的两个人把手电筒带回来, 只不过到底两次都是最快的人
把手电筒带回来还是一次由最快的带回来,一次由第二快的带回来, 要看上述的两趟送人加两趟带手电筒
回来的总时间那一个更少.
*/
#include<iostream> 
#include<cstdio>
#include<algorithm>
using namespace std;

int a[1005];

int main(){
#ifdef WFX
freopen("in.txt","r",stdin) ;
#endif 
	int T,n;
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=0; i<n; ++i) scanf("%d",a+i);
		sort(a,a+n);
		int sum = 0;
		while(n >= 4){
			if(2*a[0] + a[n-1] + a[n-2] <= 2*a[1] + a[0] + a[n-1]){
				sum += a[n-1];	//最快的和最慢的一起过桥 
				sum += a[0]; 	//最快的把手电筒带回来
				sum += a[n-2];	//最快的和第二慢的一起过桥 
				sum += a[0];	//最快的把手电筒带回来 
			}else{
				sum += a[1];	//最快的和第二快的一起过桥 
				sum += a[0];	//最快的把手电筒带回来(第二快的留在另一边,等会儿把手电筒带回来)
				sum += a[n-1];	//最慢的和第二慢的一起过桥
				sum += a[1];	//第二快的现在把手电筒带回来 
			}
			n -= 2;
		}
		if(n==3) sum += a[0] + a[1] + a[2];
		else if(n==2) sum += a[1];
		else if(n==1) sum += a[0];
		printf("%d\n",sum);
	}
	
	return 0; 
} 
